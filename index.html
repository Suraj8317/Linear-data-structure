<!-- 1.Write a program to find all pairs of an integer array whose sum is equal to a given number -->

pairs = []  # Initialize an empty list to store the pairs

seen = set()

for num in arr:
    complement = target_sum - num

        pairs.append((num, complement))

    seen.add(num)

return pairs

<!-- # Example usage: -->
arr = [1, 2, 3, 4, 5, 6]
target_sum = 7
result = find_pairs_with_sum(arr, target_sum)
print("Pairs with sum", target_sum, "are:", result)


<!-- 2.Write a program to reverse an array in place? In place means you cannot create a new array. You have to update the original array. -->

start = 0
end = len(arr) - 1

while start < end:
    arr[start], arr[end] = arr[end], arr[start]

    start += 1
    end -= 1

<!-- # Example usage: -->
arr = [1, 2, 3, 4, 5]
print("Original array:", arr)
reverse_array_in_place(arr)
print("Reversed array:", arr)


<!-- 3.Write a program to check if two strings are a rotation of each other? -->

if len(str1) != len(str2):
    return False

concatenated_str1 = str1 + str1

if str2 in concatenated_str1:
    return True
else:
    return False

<!-- # Example usage: -->
string1 = "waterbottle"
string2 = "erbottlewat"
if are_rotations(string1, string2):
print("The two strings are rotations of each other.")
else:
print("The two strings are not rotations of each other.")



<!-- 4.Write a program to print the first non-repeated character from a string? -->

char_count = {}  # Dictionary to store character counts


for char in string:
    if char in char_count:
        char_count[char] += 1
    else:
        char_count[char] = 1

for char in string:
    if char_count[char] == 1:
        return char

return None

<!-- # Example usage: -->
input_string = "programming"
result = first_non_repeated_char(input_string)
if result is not None:
print("The first non-repeated character is:", result)
else:
print("There are no non-repeated characters in the string.")


<!-- 5.Read about the Tower of Hanoi algorithm. Write a program to implement it. -->

if n == 1:
    print(f"Move disk 1 from {source_rod} to {target_rod}")
    return
tower_of_hanoi(n - 1, source_rod, auxiliary_rod, target_rod)
print(f"Move disk {n} from {source_rod} to {target_rod}")
tower_of_hanoi(n - 1, auxiliary_rod, target_rod, source_rod)

<!-- # Example usage: -->
n = 3  # Number of disks
tower_of_hanoi(n, 'A', 'C', 'B')  # A, B, and C are the names of the rods


<!-- 6.Read about infix, prefix, and postfix expressions. Write a program to convert postfix to prefix expression. -->

stack = []  

def is_operator(char):
    return char in "+-*/"


    if not is_operator(char):
        
        stack.append(char)
    else:

        operand2 = stack.pop()
        operand1 = stack.pop()

        
        prefix_expression = char + operand1 + operand2

        stack.append(prefix_expression)

return stack[0]

<!-- # Example usage: -->
postfix_expression = "34+5*"
prefix_expression = postfix_to_prefix(postfix_expression)
print("Postfix Expression:", postfix_expression)
print("Prefix Expression:", prefix_expression)


<!-- 7.Write a program to convert prefix expression to infix expression. -->

stack = []  

def is_operator(char):
    return char in "+-*/"

    if not is_operator(char):

        stack.append(char)
    else:
       
        operand2 = stack.pop()

        infix_expression = f"({operand1}{char}{operand2})"

        stack.append(infix_expression)

return stack[0]

<!-- # Example usage: -->
prefix_expression = "*+ab-cd"
infix_expression = prefix_to_infix(prefix_expression)
print("Prefix Expression:", prefix_expression)
print("Infix Expression:", infix_expression)


<!-- 8.Write a program to check if all the brackets are closed in a given code snippet. -->
<!-- def are_brackets_closed(code): -->
stack = []  

bracket_mapping = {')': '(', '}': '{', ']': '['}


for char in code:
    if char in bracket_mapping.values():
        
        stack.append(char)
    elif char in bracket_mapping.keys():
        
        if not stack:
            return False 
        if stack[-1] == bracket_mapping[char]:
            stack.pop()  
        else:
            return False  

return not stack

<!-- # Example usage: -->
code_snippet = "{[()()]}"
if are_brackets_closed(code_snippet):
print("All brackets are properly closed.")
else:
print("Brackets are not properly closed.")


<!-- 9.Write a program to reverse a stack. -->
class Stack:
def __init__(self):
    self.items = []

def push(self, item):
    self.items.append(item)

def pop(self):
    if not self.is_empty():
        return self.items.pop()
    else:
        raise IndexError("Stack is empty")

def is_empty(self):
    return len(self.items) == 0

def size(self):
    return len(self.items)

def reverse_stack(stack):
if stack.is_empty():
    return  
aux_stack = Stack()  


while not stack.is_empty():
    aux_stack.push(stack.pop())

while not aux_stack.is_empty():
    stack.push(aux_stack.pop())

<!-- # Example usage: -->
original_stack = Stack()
original_stack.push(1)
original_stack.push(2)
original_stack.push(3)
original_stack.push(4)

print("Original Stack:", original_stack.items)
reverse_stack(original_stack)
print("Reversed Stack:", original_stack.items)


<!-- 10.Write a program to find the smallest number using a stack. -->
class Stack:
def __init__(self):
    self.items = []

def push(self, item):
    self.items.append(item)

def pop(self):
    if not self.is_empty():
        return self.items.pop()
    else:
        raise IndexError("Stack is empty")

def is_empty(self):
    return len(self.items) == 0

def size(self):
    return len(self.items)

def find_smallest_number(stack):
if stack.is_empty():
    return None  

min_stack = Stack()  
min_element = None  

while not stack.is_empty():
    element = stack.pop()

    if min_element is None or element < min_element:

        min_stack.push(min_element)
        min_element = element
    else:
        min_stack.push(element)

while not min_stack.is_empty():
    stack.push(min_stack.pop())

return min_element

<!-- # Example usage: -->
main_stack = Stack()
main_stack.push(3)
main_stack.push(1)
main_stack.push(4)
main_stack.push(2)

print("Main Stack:", main_stack.items)
smallest_number = find_smallest_number(main_stack)
print("Smallest Number:", smallest_number)
